# Fitweather 최종 발표 예상 기술 질문 정리

## 📋 목차

1. [아키텍처 및 기술 스택](#1-아키텍처-및-기술-스택)
2. [날씨 API Fallback 시스템](#2-날씨-api-fallback-시스템)
3. [Firebase 및 백엔드](#3-firebase-및-백엔드)
4. [프론트엔드 아키텍처](#4-프론트엔드-아키텍처)
5. [추천 시스템](#5-추천-시스템)
6. [인증 및 보안](#6-인증-및-보안)
7. [성능 최적화](#7-성능-최적화)
8. [테스트 전략](#8-테스트-전략)
9. [에러 처리](#9-에러-처리)
10. [확장성 및 개선 방향](#10-확장성-및-개선-방향)

---

## 1. 아키텍처 및 기술 스택

### Q1-1. 왜 React를 선택했나요? 다른 프레임워크 대비 장점은?

**답변:**
- **컴포넌트 기반 개발**: 재사용 가능한 UI 컴포넌트로 개발 효율성 향상
- **풍부한 생태계**: 다양한 라이브러리와 커뮤니티 지원
- **커스텀 훅**: 비즈니스 로직을 재사용 가능한 훅으로 분리하여 관심사 분리
- **React 19**: 최신 버전 사용으로 성능 개선 및 새로운 기능 활용
- **Create React App**: 빠른 프로토타이핑 및 개발 환경 구축

### Q1-2. Firebase를 선택한 이유는? 다른 백엔드 대비 장단점은?

**답변:**
- **빠른 개발**: 서버 구축 없이 BaaS로 빠른 MVP 개발 가능
- **실시간 동기화**: Firestore의 실시간 리스너로 실시간 업데이트 지원
- **통합 인증**: Firebase Auth로 OAuth 인증 간편 구현
- **스토리지**: 이미지 업로드 및 관리 용이
- **단점**: 
  - 벤더 종속성 (이전 어려움)
  - 복잡한 쿼리 제한
  - 비용 구조 (사용량 증가 시 비용 급증)

### Q1-3. 3-Layer 아키텍처를 선택한 이유는?

**답변:**
- **Presentation Layer**: UI 컴포넌트와 페이지 분리
- **Business Logic Layer**: 커스텀 훅과 서비스로 비즈니스 로직 분리
- **Data Access Layer**: API 모듈로 데이터 접근 로직 분리
- **관심사 분리**: 각 레이어의 책임 명확화로 유지보수성 향상
- **테스트 용이성**: 각 레이어를 독립적으로 테스트 가능

---

## 2. 날씨 API Fallback 시스템

### Q2-1. 5중 Fallback 시스템을 구현한 이유는?

**답변:**
- **높은 가용성**: 단일 API 장애 시에도 서비스 지속
- **데이터 정확성**: 기상청 API를 1순위로 사용하여 한국 날씨 데이터의 정확성 보장
- **사용자 경험**: API 장애 시에도 서비스 중단 없이 사용자에게 날씨 정보 제공
- **안정성**: 5개 API 중 하나만 성공해도 서비스 제공 가능

### Q2-2. Fallback 시스템의 동작 원리를 설명해주세요.

**답변:**
1. **1순위**: 기상청(KMA) API 호출 (2초 타임아웃)
2. **실패 시**: 순차적으로 대체 API 시도
   - OpenWeatherMap → AccuWeather → WeatherAPI → Visual Crossing
3. **모든 API 실패 시**: Mock 데이터 반환 (서비스 지속성 보장)
4. **데이터 표준화**: 각 API의 서로 다른 응답 형식을 통일된 형식으로 변환
5. **API 표시**: `ApiSourceIndicator` 컴포넌트로 사용 중인 API 표시

### Q2-3. 각 API의 응답 형식이 다른데 어떻게 통일했나요?

**답변:**
- **WeatherService 클래스**: 중앙화된 데이터 처리
- **standardizeWeatherData 메서드**: 각 API의 응답을 통일된 형식으로 변환
- **공통 데이터 구조**: 
  ```javascript
  {
    temp: number,      // 온도
    rain: number,      // 강수량
    humidity: number,  // 습도
    season: string,    // 계절
    // ... 기타 필드
  }
  ```
- **API별 변환 로직**: 각 API의 고유한 응답 형식을 공통 구조로 매핑

### Q2-4. 타임아웃을 2초로 설정한 이유는?

**답변:**
- **사용자 경험**: 빠른 응답으로 사용자 대기 시간 최소화
- **Fallback 속도**: 실패 시 빠르게 대체 API로 전환
- **API 특성**: 기상청 API는 일반적으로 빠른 응답을 제공하지만, 네트워크 문제 시 지연 가능
- **균형**: 너무 짧으면 정상 응답도 실패로 처리, 너무 길면 사용자 대기 시간 증가

### Q2-5. Mock 데이터를 반환하는 것이 적절한가요?

**답변:**
- **서비스 지속성**: 모든 API 실패 시에도 앱이 크래시되지 않음
- **사용자 경험**: 기본적인 기능(착장 기록)은 계속 사용 가능
- **명확한 표시**: `ApiSourceIndicator`로 Mock 데이터임을 사용자에게 알림
- **개선 방향**: 향후 캐시된 데이터나 로컬 저장 데이터 활용 고려

---

## 3. Firebase 및 백엔드

### Q3-1. Firestore의 NoSQL 특성상 데이터 정합성을 어떻게 보장하나요?

**답변:**
- **트랜잭션**: 좋아요, 댓글 등 동시성 이슈가 있는 작업에 Firestore 트랜잭션 사용
- **Security Rules**: Firestore Security Rules로 데이터 무결성 검증
- **애플리케이션 레벨 검증**: 클라이언트에서 데이터 유효성 검사
- **참조 무결성**: 애플리케이션 로직으로 참조 무결성 보장
- **제한사항**: 복잡한 트랜잭션은 Firestore의 제한으로 어려움

### Q3-2. Firestore 쿼리 최적화는 어떻게 했나요?

**답변:**
- **인덱스 설정**: 복합 쿼리를 위한 Firestore 인덱스 설정
- **쿼리 제한**: 모든 쿼리에 `limit()` 적용하여 불필요한 데이터 조회 방지
- **페이지네이션**: 대량 데이터는 `startAfter()` 사용하여 페이지네이션 구현
- **필드 선택**: 필요한 필드만 조회 (`select()` 사용)
- **쿼리 최소화**: 클라이언트 사이드 필터링으로 서버 쿼리 최소화

### Q3-3. Firebase Storage에 이미지를 저장할 때 최적화는?

**답변:**
- **이미지 압축**: 클라이언트 사이드에서 이미지 압축 후 업로드
- **Base64 변환**: 압축된 이미지를 Base64로 변환하여 Firestore에 저장 (작은 이미지)
- **Storage 활용**: 큰 이미지는 Firebase Storage에 저장하고 URL만 Firestore에 저장
- **제한사항**: CDN 미사용, 다양한 크기의 썸네일 자동 생성 부재

### Q3-4. 실시간 동기화는 어떻게 구현했나요?

**답변:**
- **Firestore 리스너**: `onSnapshot()`을 사용한 실시간 리스너
- **알림 시스템**: 새 기록, 댓글, 좋아요 등에 대한 실시간 알림
- **성능 고려**: 필요한 경우에만 리스너 등록, 컴포넌트 언마운트 시 리스너 해제
- **제한사항**: 다수의 실시간 리스너로 인한 성능 저하 가능성

---

## 4. 프론트엔드 아키텍처

### Q4-1. 상태 관리를 Context API만 사용한 이유는?

**답변:**
- **단순성**: 전역 상태가 많지 않아 Context API로 충분
- **의존성 최소화**: 추가 라이브러리 없이 React 기본 기능 활용
- **인증 상태**: `AuthContext`로 인증 상태만 전역 관리
- **제한사항**: 
  - 복잡한 상태 관리에 부적합
  - Context 변경 시 불필요한 리렌더링 가능
  - 향후 Redux나 Zustand 도입 고려

### Q4-2. 커스텀 훅을 많이 사용한 이유는?

**답변:**
- **재사용성**: 비즈니스 로직을 재사용 가능한 훅으로 분리
- **관심사 분리**: UI 로직과 비즈니스 로직 분리
- **테스트 용이성**: 훅을 독립적으로 테스트 가능
- **코드 가독성**: 컴포넌트 코드 간결화
- **예시**: `useWeather`, `useFeedData`, `useRecordForm` 등 15개 커스텀 훅

### Q4-3. 컴포넌트 구조는 어떻게 설계했나요?

**답변:**
- **페이지 컴포넌트**: `src/pages/` - 주요 화면 (18개)
- **재사용 컴포넌트**: `src/components/` - 공통 UI 컴포넌트 (13개)
- **커스텀 훅**: `src/hooks/` - 비즈니스 로직 (15개)
- **API 모듈**: `src/api/` - 데이터 접근 계층 (19개)
- **유틸리티**: `src/utils/` - 헬퍼 함수 (14개)

### Q4-4. Props Drilling 문제는 어떻게 해결했나요?

**답변:**
- **커스텀 훅**: 깊은 컴포넌트 계층에서도 훅으로 직접 데이터 접근
- **Context API**: 인증 상태 등 전역 상태는 Context로 관리
- **제한사항**: 일부 컴포넌트에서 여전히 Props Drilling 발생
- **개선 방향**: 상태 관리 라이브러리 도입 고려

---

## 5. 추천 시스템

### Q5-1. 추천 알고리즘은 어떻게 구현했나요?

**답변:**
- **계절 기반**: 현재 계절에 맞는 기록 필터링
- **스타일 필터**: 사용자 선호 스타일 기반 필터링
- **인기순 정렬**: 좋아요 수 기준 정렬 (좋아요 내림차순 → 싫어요 오름차순 → 최신순)
- **지역 우선**: 해당 지역의 오늘 기록 우선 추천
- **Fallback**: 지역 일치 기록이 없으면 전체 기록에서 추천

### Q5-2. 추천 시스템의 정확도를 어떻게 평가하나요?

**답변:**
- **현재**: 정량적 평가 지표 없음
- **사용자 피드백**: 사용자의 좋아요/싫어요 반응으로 간접 평가
- **제한사항**: 
  - 머신러닝 기반 추천 부재
  - 개인화 제한적
  - 사용자 선호도 학습 부족
- **개선 방향**: 
  - 협업 필터링 도입
  - 사용자 행동 데이터 수집 및 분석
  - A/B 테스트로 추천 알고리즘 개선

### Q5-3. 추천 성능은 어떻게 최적화했나요?

**답변:**
- **쿼리 제한**: 최대 100-200개 기록만 조회 후 클라이언트 사이드 필터링
- **메모이제이션**: `useMemo`로 추천 결과 캐싱
- **지연 로딩**: 필요할 때만 추천 데이터 로드
- **제한사항**: 모든 공개 기록을 조회하는 것은 확장성 문제 가능

---

## 6. 인증 및 보안

### Q6-1. OAuth 인증은 어떻게 구현했나요?

**답변:**
- **구글 로그인**: Firebase Auth의 `GoogleAuthProvider` 사용 (Popup 방식)
- **카카오 로그인**: 커스텀 OAuth 구현 (Redirect 방식)
  - 카카오 OAuth 인증 코드 받기
  - 액세스 토큰 요청
  - 사용자 정보 조회
  - Firebase 커스텀 토큰 생성
- **통합**: 두 방식 모두 Firebase Auth로 통합하여 일관된 인증 상태 관리

### Q6-2. 보안은 어떻게 보장하나요?

**답변:**
- **Firebase Security Rules**: Firestore 및 Storage 접근 제어
- **인증 검증**: 모든 보호된 리소스는 인증 필수
- **권한 체크**: 작성자만 수정/삭제 가능
- **제한사항**: 
  - 클라이언트 사이드 검증만으로는 보안 취약
  - API 키가 클라이언트에 노출 (날씨 API)
  - 향후 백엔드 프록시 서버 구축 필요

### Q6-3. 사용자 차단 기능은 어떻게 구현했나요?

**답변:**
- **상태 필드**: `users.status === 'banned'`로 차단 상태 관리
- **인증 시 체크**: `AuthContext`에서 로그인 시 차단 상태 확인
- **자동 로그아웃**: 차단된 사용자는 자동으로 로그아웃 처리
- **관리자 기능**: 관리자가 사용자 차단/해제 가능

### Q6-4. API 키 보안은 어떻게 관리하나요?

**답변:**
- **환경 변수**: `REACT_APP_` 접두사로 환경 변수 사용
- **제한사항**: 
  - CRA의 환경 변수는 빌드 시 번들에 포함되어 클라이언트에 노출
  - 날씨 API 키가 클라이언트에 노출됨
- **개선 방향**: 
  - 백엔드 프록시 서버 구축
  - API 키를 서버에서만 관리
  - 클라이언트는 프록시 서버를 통해 날씨 데이터 요청

---

## 7. 성능 최적화

### Q7-1. 프론트엔드 성능 최적화는 어떻게 했나요?

**답변:**
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo/useCallback**: 비용이 큰 계산 및 함수 캐싱
- **코드 스플리팅**: 제한적 (CRA 제약)
- **이미지 최적화**: 클라이언트 사이드 압축
- **제한사항**: 
  - 번들 크기 최적화 제한 (CRA 제약)
  - 라우트 기반 코드 스플리팅 미구현
  - 향후 React.lazy 및 Suspense 활용 고려

### Q7-2. 데이터베이스 쿼리 성능은 어떻게 최적화했나요?

**답변:**
- **인덱스**: 복합 쿼리를 위한 Firestore 인덱스 설정
- **쿼리 제한**: 모든 쿼리에 `limit()` 적용
- **페이지네이션**: `startAfter()` 사용
- **필드 선택**: 필요한 필드만 조회
- **제한사항**: 
  - 복잡한 집계 연산 제한
  - 클라이언트 사이드 필터링으로 인한 성능 저하 가능

### Q7-3. 이미지 로딩 성능은 어떻게 최적화했나요?

**답변:**
- **압축**: 클라이언트 사이드에서 이미지 압축
- **Base64**: 작은 이미지는 Base64로 Firestore에 저장
- **제한사항**: 
  - CDN 미사용
  - 다양한 크기의 썸네일 자동 생성 부재
  - 지연 로딩 제한적
- **개선 방향**: 
  - 이미지 CDN 도입
  - 썸네일 자동 생성
  - 지연 로딩 구현

---

## 8. 테스트 전략

### Q8-1. 테스트 커버리지는 어느 정도인가요?

**답변:**
- **총 테스트 파일**: 16개
- **총 테스트 케이스**: 151개
- **테스트 통과율**: 100%
- **테스트 유형**: 
  - 단위 테스트: 유틸리티, 서비스, API, 컴포넌트
  - 통합 테스트: API 통합, 사용자 플로우
- **제한사항**: 
  - E2E 테스트 부재
  - 테스트 커버리지 목표: 80% 이상 (현재 미달 가능)

### Q8-2. Firebase를 어떻게 모킹했나요?

**답변:**
- **Firebase 모크**: `__mocks__/firebase.js`에 완전한 Firebase 모크 구현
- **Firestore 모크**: `collection`, `doc`, `getDocs`, `addDoc` 등 주요 함수 모크
- **Auth 모크**: 인증 관련 함수 모크
- **Storage 모크**: 스토리지 함수 모크
- **외부 API 모크**: 날씨 API 모크 구현

### Q8-3. 통합 테스트는 어떻게 구현했나요?

**답변:**
- **API 통합 테스트**: 날씨 API Fallback 시스템 통합 테스트
- **사용자 플로우 테스트**: 
  - 착장 기록 생성 및 좋아요 플로우
  - 알림 생성 및 조회 플로우
- **실제 Firebase 연결 없이**: 모크를 사용하여 테스트
- **제한사항**: 실제 외부 API 호출 없이 테스트

---

## 9. 에러 처리

### Q9-1. 에러 처리는 어떻게 구현했나요?

**답변:**
- **전역 에러 핸들러**: `App.js`에서 전역 에러 및 Promise 거부 처리
- **try-catch**: 모든 비동기 작업에 try-catch 적용
- **Fallback 로직**: 날씨 API 실패 시 대체 API 시도
- **사용자 알림**: `react-toastify`로 에러 메시지 표시
- **에러 타입별 처리**: 
  - 네트워크 에러: 재시도 로직
  - 인증 에러: 로그인 페이지로 리다이렉트
  - 권한 에러: 에러 메시지 표시

### Q9-2. Firestore 내부 오류는 어떻게 처리하나요?

**답변:**
- **오류 감지**: `INTERNAL ASSERTION FAILED` 등 Firestore 내부 오류 감지
- **무시 처리**: 실제 기능에 영향을 주지 않는 내부 오류는 무시
- **로깅**: 모든 에러는 콘솔에 로깅
- **사용자 안내**: 페이지 새로고침으로 해결 가능하다고 안내

### Q9-3. 네트워크 에러 시 재시도 로직은?

**답변:**
- **날씨 API**: Fallback 시스템으로 자동 재시도
- **일반 API**: 현재 재시도 로직 제한적
- **개선 방향**: 
  - Exponential Backoff 재시도 로직 구현
  - 네트워크 상태 감지 및 오프라인 처리
  - 재시도 횟수 제한 및 사용자 알림

---

## 10. 확장성 및 개선 방향

### Q10-1. 현재 시스템의 확장성 한계는?

**답변:**
- **Firebase 의존성**: Firebase에 완전히 종속되어 이전 어려움
- **쿼리 제한**: 복잡한 쿼리 및 집계 연산 제한
- **비용 구조**: 사용량 증가 시 비용 급증 가능
- **수평 확장**: Firebase에 의존한 확장성
- **캐싱 전략**: Redis 등 캐싱 레이어 없음

### Q10-2. 향후 개선 계획은?

**답변:**
- **단기 (1-3개월)**:
  - TypeScript 도입
  - 에러 바운더리 추가
  - 이미지 최적화
  - 테스트 커버리지 향상
- **중기 (3-6개월)**:
  - 상태 관리 라이브러리 도입 (Zustand/Redux)
  - 코드 스플리팅
  - API 프록시 서버 구축
  - 캐싱 전략 (React Query/SWR)
  - 모니터링 도구 통합 (Sentry)
- **장기 (6개월 이상)**:
  - 아키텍처 리팩토링
  - 백엔드 분리 검토
  - CI/CD 파이프라인 구축
  - 성능 최적화 (번들 최적화, CDN)
  - 다국어 지원 (i18n)

### Q10-3. 대규모 사용자 지원을 위해 필요한 개선은?

**답변:**
- **백엔드 분리**: Firebase에서 독립적인 백엔드 서버 구축
- **캐싱 레이어**: Redis 등 캐싱 레이어 도입
- **로드 밸런싱**: 수평 확장을 위한 로드 밸런서
- **CDN**: 이미지 및 정적 자원 CDN 활용
- **데이터베이스 최적화**: 쿼리 최적화 및 인덱스 튜닝
- **모니터링**: 성능 메트릭 수집 및 분석

### Q10-4. 검색 기능이 없는 이유는?

**답변:**
- **MVP 우선순위**: 핵심 기능(착장 기록, 소셜 기능) 우선 개발
- **Firestore 제한**: 전체 텍스트 검색 기능 제한
- **개선 방향**: 
  - Algolia 등 검색 서비스 통합
  - 또는 Elasticsearch 도입
  - 태그 기반 검색 구현

---

## 추가 질문 대비

### Q. 프로젝트에서 가장 어려웠던 부분은?

**답변:**
- **날씨 API Fallback 시스템**: 여러 API의 응답 형식을 통일하는 것이 어려웠음
- **Firebase Security Rules**: 복잡한 권한 로직을 Security Rules로 구현하는 것이 어려웠음
- **실시간 동기화**: 다수의 실시간 리스너로 인한 성능 이슈 해결
- **카카오 OAuth**: Firebase Auth와 통합하는 과정이 복잡했음

### Q. 프로젝트에서 가장 자랑하고 싶은 부분은?

**답변:**
- **5중 Fallback 시스템**: 높은 가용성을 보장하는 견고한 시스템
- **커스텀 훅 아키텍처**: 관심사 분리를 통한 깔끔한 코드 구조
- **테스트 인프라**: 151개의 테스트 케이스로 안정성 보장
- **사용자 경험**: API 장애 시에도 서비스가 중단되지 않는 안정성

### Q. 프로젝트를 다시 시작한다면 무엇을 다르게 할까요?

**답변:**
- **TypeScript 도입**: 타입 안정성 확보
- **상태 관리 라이브러리**: 초기부터 Zustand나 Redux 도입
- **백엔드 분리**: API 키 보호를 위한 백엔드 서버 구축
- **테스트 우선**: TDD 방식으로 개발
- **CI/CD**: 초기부터 자동화된 배포 파이프라인 구축

---

## 발표 팁

1. **기술적 깊이**: 각 질문에 대해 구체적인 코드 예시나 아키텍처 다이어그램으로 설명
2. **한계 인정**: 제한사항을 솔직하게 설명하고 개선 방향 제시
3. **실제 경험**: 실제 개발 중 겪은 문제와 해결 과정 공유
4. **미래 비전**: 향후 개선 계획과 확장 가능성 강조
5. **데이터 기반**: 테스트 통과율, 코드 라인 수 등 정량적 데이터 활용

---

**작성일**: 2024년
**프로젝트**: Fitweather - 날씨 기반 착장 기록 및 공유 플랫폼

