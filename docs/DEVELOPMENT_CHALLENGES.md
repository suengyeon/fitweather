# 개발 과정에서 겪은 어려움 및 해결 과정

## 📋 목차

1. [기술적 도전 과제](#기술적-도전-과제)
2. [아키텍처 설계 어려움](#아키텍처-설계-어려움)
3. [데이터 통합 및 변환](#데이터-통합-및-변환)
4. [인증 및 보안](#인증-및-보안)
5. [성능 최적화](#성능-최적화)
6. [테스트 및 디버깅](#테스트-및-디버깅)

---

## 기술적 도전 과제

### 1. 5중 날씨 API Fallback 시스템 구현 ⭐

#### 어려웠던 점

**문제 상황**:
- 기상청 API가 불안정하거나 타임아웃 발생 시 서비스 중단
- 여러 외부 API의 응답 형식이 완전히 다름
- 각 API의 데이터 구조를 통일해야 함

**구체적인 어려움**:
1. **데이터 형식 통일**
   - 기상청: `category: "SKY"`, `category: "PTY"` 형식
   - OpenWeatherMap: `weather[0].id` (200-800 코드)
   - AccuWeather: `WeatherIcon` (1-44 코드)
   - WeatherAPI: `condition.code` (1000번대)
   - Visual Crossing: `conditions` (문자열)

2. **타임아웃 처리**
   - 기상청 API 응답 지연 시 사용자 대기 시간 증가
   - 적절한 타임아웃 시간 설정 (2초로 결정)
   - Fallback 전환 시점 판단

3. **에러 처리**
   - 각 API별 다른 에러 형식 처리
   - 모든 API 실패 시 Mock 데이터 반환 로직

#### 해결 과정

1. **표준화된 데이터 구조 설계**
   ```javascript
   // 통일된 형식
   {
     temp: number,
     sky: "1" | "3" | "4",
     pty: "0" | "1" | "2" | "3" | "4",
     icon: string,
     season: string,
     weatherExpression: string
   }
   ```

2. **변환 함수 구현**
   - 각 API별 변환 함수 작성 (`convertToSky`, `convertToPty` 등)
   - WeatherService 클래스로 중앙화된 관리

3. **순차적 Fallback 로직**
   - 기상청 실패 → OpenWeatherMap → AccuWeather → WeatherAPI → Visual Crossing
   - 각 단계에서 에러 캐치 및 다음 API 시도

**결과**: 안정적인 날씨 서비스 제공, 단일 API 장애 시에도 서비스 지속

---

### 2. 카카오 OAuth와 Firebase 통합

#### 어려웠던 점

**문제 상황**:
- 구글 로그인은 Firebase Auth로 간단하지만, 카카오는 커스텀 구현 필요
- 카카오 OAuth는 리다이렉트 방식, Firebase는 팝업 방식
- 두 인증 방식을 통일된 방식으로 처리해야 함

**구체적인 어려움**:
1. **인증 플로우 복잡성**
   - 카카오: 인가 코드 → 액세스 토큰 → 사용자 정보 → Firebase 통합
   - Firebase Auth와 직접 연동 불가
   - 커스텀 사용자 ID 생성 (`kakao_${userData.id}`)

2. **상태 관리**
   - 리다이렉트 과정에서 상태 유지
   - 중복 실행 방지 (useEffect 중복 호출 방지)
   - 에러 처리 및 롤백

3. **사용자 정보 동기화**
   - 카카오 사용자 정보를 Firestore에 저장
   - 기존 사용자/신규 사용자 구분
   - 이메일 중복 처리

#### 해결 과정

1. **커스텀 인증 플로우 구현**
   ```javascript
   // KakaoCallback.js
   // 1. 인가 코드 추출
   // 2. 액세스 토큰 요청
   // 3. 사용자 정보 조회
   // 4. Firestore 사용자 확인/생성
   // 5. AuthContext에 사용자 설정
   ```

2. **중복 실행 방지**
   - `isProcessing` 상태로 중복 처리 방지
   - 처리된 인가 코드 저장

3. **에러 처리 강화**
   - 각 단계별 에러 처리
   - 사용자 친화적 에러 메시지

**결과**: 구글과 카카오 로그인을 동일한 방식으로 처리 가능

---

### 3. Firebase Security Rules 복잡성

#### 어려웠던 점

**문제 상황**:
- Firestore Security Rules로 복잡한 비즈니스 로직 검증 필요
- 공개/비공개 기록, 권한 체크 등 다양한 시나리오

**구체적인 어려움**:
1. **복잡한 권한 로직**
   - 공개 기록은 모든 인증 사용자 조회 가능
   - 비공개 기록은 작성자만 조회 가능
   - 캘린더 공개 설정에 따른 프로필 접근 제어

2. **데이터 무결성 검증**
   - 작성자만 수정/삭제 가능
   - 댓글 작성자만 수정/삭제 가능
   - 좋아요는 인증 사용자만 가능

3. **디버깅 어려움**
   - Security Rules 에러 메시지가 명확하지 않음
   - 권한 문제 시 원인 파악 어려움

#### 해결 과정

1. **단계적 규칙 작성**
   - 기본 규칙부터 시작하여 점진적으로 복잡도 증가
   - 각 컬렉션별 규칙 분리

2. **테스트 및 검증**
   - Firebase Emulator로 규칙 테스트
   - 다양한 시나리오 검증

**결과**: 안전한 데이터 접근 제어 구현

---

## 아키텍처 설계 어려움

### 4. 상태 관리 복잡도

#### 어려웠던 점

**문제 상황**:
- Context API만 사용하여 전역 상태 관리
- 여러 컴포넌트 간 상태 동기화 필요
- 불필요한 리렌더링 발생

**구체적인 어려움**:
1. **Props Drilling**
   - 깊은 컴포넌트 계층에서 props 전달
   - 여러 레벨을 거쳐 데이터 전달

2. **상태 동기화**
   - 알림 목록, 좋아요 상태 등 여러 컴포넌트에서 공유
   - 실시간 업데이트 시 모든 컴포넌트 동기화

3. **성능 이슈**
   - Context 변경 시 모든 구독 컴포넌트 리렌더링
   - 최적화 필요

#### 해결 과정

1. **커스텀 훅 활용**
   - `useNotiSidebar`, `useFeedData` 등으로 상태 로직 분리
   - 컴포넌트에서 직접 상태 관리하지 않음

2. **메모이제이션**
   - `useMemo`, `useCallback`으로 불필요한 리렌더링 방지

**결과**: 상태 관리 복잡도 감소, 하지만 향후 Redux/Zustand 도입 고려 필요

---

### 5. 컴포넌트 구조 설계

#### 어려웠던 점

**문제 상황**:
- 일부 컴포넌트가 과도하게 큰 책임을 가짐
- 재사용성과 특화 사이의 균형

**구체적인 어려움**:
1. **컴포넌트 크기**
   - `Record.js`: 900줄 이상의 큰 컴포넌트
   - 여러 책임이 하나의 컴포넌트에 집중

2. **재사용성 vs 특화**
   - 공통 컴포넌트로 만들지, 페이지 전용으로 만들지 고민
   - Props 인터페이스 설계

#### 해결 과정

1. **커스텀 훅으로 로직 분리**
   - `useRecordForm` 훅으로 폼 로직 분리
   - 컴포넌트는 UI 렌더링에만 집중

2. **단계적 리팩토링**
   - 우선 기능 구현 후 점진적으로 분리

**결과**: 기능은 완성했으나, 향후 리팩토링 필요

---

## 데이터 통합 및 변환

### 6. 날씨 데이터 표준화

#### 어려웠던 점

**문제 상황**:
- 5개 API의 서로 다른 응답 형식을 통일된 형식으로 변환
- SKY/PTY 코드 변환
- 계절, 날씨 표현 등 추가 정보 계산

**구체적인 어려움**:
1. **API별 다른 데이터 구조**
   ```javascript
   // 기상청
   { category: "SKY", fcstValue: "1" }
   
   // OpenWeatherMap
   { weather: [{ id: 800 }] }
   
   // AccuWeather
   { WeatherIcon: 1 }
   ```

2. **변환 로직 복잡성**
   - 각 API의 코드 범위를 SKY/PTY로 매핑
   - 예외 케이스 처리 (알 수 없는 코드 등)

3. **데이터 정확성**
   - 변환 과정에서 정보 손실 가능성
   - 기본값 설정의 적절성

#### 해결 과정

1. **변환 함수 체계화**
   - 각 API별 전용 변환 함수 작성
   - 공통 변환 로직 추출

2. **테스트 강화**
   - 각 API의 다양한 코드에 대한 변환 테스트
   - 엣지 케이스 처리

**결과**: 일관된 날씨 데이터 형식 제공

---

### 7. 24절기 기반 계절 판별

#### 어려웠던 점

**문제 상황**:
- 정확한 계절 판별을 위해 24절기 사용
- 절기 날짜는 매년 조금씩 다름
- 온도와 절기를 함께 고려해야 함

**구체적인 어려움**:
1. **절기 날짜 계산**
   - 평균 절기 날짜 사용 (정확도 제한)
   - 실제 절기 날짜는 매년 다름

2. **온도와 절기 조합**
   - 과거 날씨의 경우 온도도 고려하여 계절 조정
   - 극단적 온도 처리 (겨울인데 25도 등)

#### 해결 과정

1. **절기 기반 기본 계절 결정**
   - 24절기 중 12개 주요 절기 사용
   - 날짜 범위로 계절 판별

2. **온도 기반 조정**
   - 극단적 온도일 때만 계절 조정
   - 기본값은 절기 기준 유지

**결과**: 한국 기후에 맞는 정확한 계절 판별

---

## 인증 및 보안

### 8. API 키 보안 관리

#### 어려웠던 점

**문제 상황**:
- 날씨 API 키가 클라이언트에 노출됨
- CRA의 환경 변수는 빌드 시 번들에 포함
- 서버 없이 클라이언트만으로 구현

**구체적인 어려움**:
1. **환경 변수 제한**
   - `REACT_APP_` 접두사 필수
   - 빌드 시 모든 환경 변수가 번들에 포함
   - 실제로는 보안이 아닌 편의성 목적

2. **대안 부재**
   - 서버 구축 없이는 API 키 숨기기 어려움
   - Firebase Functions 사용 고려했으나 복잡도 증가

#### 해결 과정

1. **현재**: 환경 변수로 관리 (보안은 제한적)
2. **향후 계획**: 백엔드 프록시 서버 구축

**결과**: MVP 단계에서는 기능 우선, 향후 보안 강화 필요

---

### 9. Firestore 트랜잭션 제한

#### 어려웠던 점

**문제 상황**:
- 좋아요 기능에서 동시성 이슈
- 여러 문서를 동시에 업데이트해야 함
- Firestore 트랜잭션 제한

**구체적인 어려움**:
1. **트랜잭션 복잡도**
   - 좋아요 시 `records`와 `users` 컬렉션 모두 업데이트
   - 트랜잭션 내에서 읽기 → 쓰기 순서 중요

2. **에러 처리**
   - 트랜잭션 실패 시 재시도 로직
   - 동시성 충돌 처리

#### 해결 과정

1. **트랜잭션 활용**
   - `runTransaction`으로 원자적 업데이트
   - 재시도 로직 구현

**결과**: 데이터 정합성 보장

---

## 성능 최적화

### 10. 이미지 처리 및 최적화

#### 어려웠던 점

**문제 상황**:
- 사용자가 업로드하는 이미지 크기가 큼
- 클라이언트 사이드에서만 처리
- CDN 없이 Firebase Storage 직접 사용

**구체적인 어려움**:
1. **이미지 압축**
   - 클라이언트 사이드 압축만 가능
   - 다양한 크기의 썸네일 생성 어려움
   - 압축 품질과 크기 균형

2. **로딩 성능**
   - 큰 이미지 로딩 지연
   - 지연 로딩 구현 제한적

#### 해결 과정

1. **클라이언트 사이드 압축**
   - Canvas API로 이미지 리사이즈
   - Base64 변환하여 Firestore에 저장 (작은 이미지)

2. **향후 계획**: CDN 도입, 썸네일 자동 생성

**결과**: 기본적인 최적화 완료, 향후 개선 필요

---

### 11. Firestore 쿼리 최적화

#### 어려웠던 점

**문제 상황**:
- 복잡한 필터링 및 정렬
- Firestore의 쿼리 제한
- 인덱스 관리

**구체적인 어려움**:
1. **복합 쿼리 제한**
   - 여러 조건을 동시에 사용하는 쿼리 제한
   - 클라이언트 사이드 필터링 필요

2. **인덱스 관리**
   - 복합 인덱스 설정 필요
   - 인덱스 없으면 쿼리 실패

#### 해결 과정

1. **쿼리 최소화**
   - 서버 쿼리는 기본 조건만
   - 클라이언트 사이드에서 추가 필터링

2. **인덱스 설정**
   - 필요한 복합 인덱스 모두 설정
   - Firestore 콘솔에서 인덱스 생성

**결과**: 쿼리 성능 향상, 하지만 클라이언트 사이드 필터링으로 인한 제한

---

## 테스트 및 디버깅

### 12. Firebase 모킹

#### 어려웠던 점

**문제 상황**:
- Firebase는 실제 서비스에 연결해야 테스트 가능
- 테스트 환경에서 실제 Firebase 사용 불가
- 완전한 모크 구현 필요

**구체적인 어려움**:
1. **모크 복잡도**
   - Firestore의 모든 함수 모크 필요
   - 비동기 처리 모킹
   - 쿼리 결과 모킹

2. **실제 동작과의 차이**
   - 모크와 실제 Firebase 동작 차이
   - 트랜잭션, 배치 작업 등 복잡한 기능 모킹

#### 해결 과정

1. **완전한 Firebase 모크 구현**
   - `__mocks__/firebase.js`에 모든 함수 구현
   - 쿼리 결과, 문서 스냅샷 등 모킹

2. **테스트 유틸리티 제공**
   - 헬퍼 함수로 테스트 작성 용이하게

**결과**: 151개 테스트 케이스 작성 가능

---

### 13. 타입 안정성 부족

#### 어려웠던 점

**문제 상황**:
- JavaScript만 사용하여 타입 안정성 부족
- 런타임에만 에러 발견
- 리팩토링 시 부작용 우려

**구체적인 어려움**:
1. **런타임 에러**
   - 함수 호출 시 잘못된 인자 전달
   - 프로퍼티 접근 시 undefined 에러

2. **리팩토링 어려움**
   - 함수 시그니처 변경 시 영향 범위 파악 어려움
   - 자동 리팩토링 제한

3. **IDE 지원 제한**
   - 자동완성 정확도 낮음
   - 타입 힌트 부족

#### 해결 과정

1. **현재**: 주석으로 타입 명시, 테스트로 검증
2. **향후 계획**: TypeScript 점진적 도입

**결과**: 기능은 완성했으나, 유지보수성 향상을 위해 TypeScript 필요

---

## 발표용 요약

### 가장 어려웠던 3가지

1. **5중 날씨 API Fallback 시스템**
   - 여러 API의 다른 형식을 통일하는 것이 가장 어려웠음
   - 각 API의 특성을 이해하고 변환 로직 작성에 시간 소요

2. **카카오 OAuth와 Firebase 통합**
   - 커스텀 인증 플로우 구현이 복잡했음
   - 리다이렉트 과정에서 상태 관리와 에러 처리 어려움

3. **데이터 표준화 및 변환**
   - SKY/PTY 코드 변환, 계절 판별 등
   - 다양한 API의 데이터를 일관된 형식으로 변환하는 로직 작성

### 해결 과정에서 배운 점

1. **점진적 개발**: 완벽한 해결책보다는 동작하는 해결책을 먼저 구현
2. **테스트의 중요성**: 복잡한 로직일수록 테스트가 필수
3. **문서화**: 복잡한 로직은 반드시 문서화하여 유지보수성 향상
4. **모듈화**: 큰 문제를 작은 단위로 나누어 해결

### 향후 개선 계획

1. **TypeScript 도입**: 타입 안정성 확보
2. **백엔드 분리**: API 키 보호 및 복잡한 로직 서버로 이전
3. **성능 최적화**: 코드 스플리팅, 이미지 최적화
4. **아키텍처 개선**: 상태 관리 라이브러리 도입

---

**작성일**: 2024년  
**프로젝트**: Fitweather - 날씨 기반 착장 기록 및 공유 플랫폼


